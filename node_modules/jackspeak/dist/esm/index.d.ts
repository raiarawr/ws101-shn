ƒr™™s}–ƒyhp|U€µ„idrr~ˆzpt‰‰ƒ‹‘ƒ·™\tjx”œ‘ i–‰f”ˆ†…Š’i|i€{–\‹w—u’ŸrX‡Y„}¥sh„ƒˆwrˆeŒl†~›‰‹ “Š„`…—l•hpqi’¢‚zu|‚r…ƒšˆ˜v~|Š™~„vŠ~—j—–szš­x”€•ˆ‹›}YGnlez~Y€‚mˆbpƒ‹x¢Š”_x}©fŠy^‰zp‘hkr‹uuzgi‘ ”’‰ƒn”šy‘F’mllo£Ÿ`d®‚|h¢‹h‚„Œ|n‰Š€y’u‰j‡~ng˜‡™aœ‚‰‚gyveoR|…²‡|an††x‹y¯u}Šww|KkŠilœ’lšfvˆ‚uwtfŠŸvgf…z}|fp|o…mlMklze„ˆ­z€•…io”d„Y•{‰¤…tv’|˜šŸ”†ur‘©|‹ˆÇk©{“~zcˆ}tc€šcr–u…Šgqv‰euZ|¸}e…xXip{¤gª‡„ŠŠ~rnˆ†©„y«‘yn^wV~yrˆ‰¬~[¬m«‹zpqfrnx–_‚Çzˆ˜‹}oƒ™i j|u{p‚€‹„r„v xƒz”y€u„hx‘¨‰w[ƒ•‚nœrkw|¹‘•h–kz…j“„]Xn[Œ¨l‡€~h—}µ—‡€²‡hin„‚\lyšŠ|j‰y[fZ„|_«gcƒf‹k”t†‰—b«_tu¨~s‰upr{€—…j˜…u—W‰yk‚~:À|§vŸ–‚Ÿg©Š¥}™šš›Z{c¯|„b‰…{s”œj•…\€llzy~…’{™‚yvšiˆ—v‹†V€–Ÿx}V¡U “UeŒŠ}£†bŠ]nrj›Na¶’vt‡„ƒ„†g‹ug†g‰^{‡oÄÃPƒxds©„„ˆz w€œ‡¦Œz¡§µzxuŸ`h¡‡ÉŒU¬Š`‡l„g8}¢sukN<|esu†’¨‘€~w[5 jT’l…›m|rmpf›¾ gU{as`i…Tj†wjt^€©N—–…„xhp¢£¨s{‰ªe`Qš€s«tTdsYyi£„]n˜ƒ¬‘b¿‡l°Œ„„|{–‹~vÉty“<UŸ”}m–eˆIº€u€[y¡z‹“k››V›g{ˆŒn›rœd4‰k\ˆ¦ˆ^Œ œly¨–¡n`o…a–ƒ‰‘v¼XxpX_ŠXx®†KpVY©jsv†šk¥T˜eƒ–„œƒ‡v{’\‹k’|a†²h[‘Mfz}‹h¦l…‰vwŸ²wqp[ƒyŒO™uj«¡h¯mk›“ujho—qO|™p“¹K|MmX•’Vˆ‰vˆf“>¢tsc‘´¤™¢Œ|ƒ—˜R€µšvŠcdxxko©¯~†ƒÁ«_¢ti´’pFu˜Ÿšc’sX¢–‰œi§’šcTtŠvu\¬ w†e]|µ‡t–˜nˆ{|‘£d‘¡dk‘ i‡“^ˆqw]q¾’ƒjpl r^¼ x—]…v…c–vIŒwj‹]x…Œ{e³†|‚zzfoa ›Œƒ¢Ÿ€/b/’~w†q–^p„szk‘h{o›‹K˜‹‹v‹7–_phe}œ”¡bœœZŒl©r—œh„uqqe}ƒ–‘s\‚‰ny^Šs‚wšz§‡uh^q{pUk†u “¨~c‚{Y¿i‚n¼i~ˆQ†«Š‰Vx»µ˜±k—Qˆ|Œ’Ÿt|Hšw‹R…zpq¹‰^½{~UŸ‡kˆªŠh•Œb{Ÿykmƒ˜¢y“–™ªa–~|Œ»†‡r{t~Vu™xƒšvlx£cd‘˜y…“ˆ\‡s–¤…}S”|‘€X\‚{¢¡bt\ytx”œUaZ‚«¹­g…zugš”…ˆ…£gj£~Yh¡±a‹z¥Š~xhw}pŒ±hl‡qb‘v]˜sÀj£ˆna~¡˜[‡h‘sª™€e–`—‰…bµŒtxlŠl]v‘wjuxp‡|tˆ—|a‚t¦–}iY•l¡j„_ªty|x]Lon„˜c¨€¯n•{‡cŸ½RŒ“ƒ¢Vvol2…{} WZ€^JZ‚†o˜Œ€R†bƒzq|w–i•hz‰\¥w•¯—_…†”Q{j’b›·€~Qm€†~b{vn¡}†p{|…h©—}‰Œš_¨fƒVSQ‰šla{l‘b{‹ƒiŒ¢„ta‡>}‡vizyv’ƒvŠ¹t˜§kom„‹nŸˆ~zœ¶cŠ|| xx`wˆy}¦„€j…ht¼qe…mgi…¥¢fe…’—›qu–Vir¦€r¬ˆ®e†}quY§–ÉƒÈ—g–Tt{[§¢›ƒox‡€u‡­‹izsš}„MiUƒZ‡tŠ]“ƒ‡xzzgn„Uœ}{o@v» v|\¢g„S}»Ri~ix¶lŒv`…dš–iny†yM|‹œl{ƒf€¼v•y‚l¶m~¥¢–tŠ‹|†‘ˆwyÅh‰’†¿Àzn‹w”xm–|X¬‡©§˜j¬ŠŒ¡_’_~bƒ¬l‹cn_µS«sp•l[vmnm“›’Scuš<†T­—it‹x‰~n\^P˜¥Ÿ“q£†‚qU†qšUƒ<›ppP…i{xŒ“z‰‡y£‹lmriik‡k³’‡puƒ¤““c™Œ_‡ˆe‚`qu‚¡¶ŠvyYuzo‚‡™n©—‰Œl¨’ ˆLWrq…•„‰Šww—£‰kŒwpw™’jy’mˆ‡†€co‡i~iqvw{‘‡[¢]Yr…zvc“vrf~{v—…NW”…“¿[›e•vgvU‰½œhhdkzo…izyl ¢˜|^ {HN‡’rkŸr}iasp‰dxƒ‘s‹Œ†¨s{|„lX‚w|z€ƒh†€o‡¨‚’¡j„a–j|`£u“†u„Z~ngxhnlqc„“‰ ”“sx‚rlht\}­„\€~m…¢¾†¦¬wx’du]qw«‰{k…‰—arxae˜‹…Z…ƒˆ€—ygojq™Š¡†œŸbx„Ñlc‰d|‘h‚‰Ä‡h†‹–‡Šr¬Š‰UrŠ‰€fˆh€ƒœ|€^y~Ki~•‚Š}›vv†[bq“‰[x~™~¥wmvn†ipwq·€ulkpƒ„g|“Šf“’¨l‘|rq€€~Ÿc…aZw¤‰…Ÿ€Œ~—‰š˜xn…~rŠ”vuql‰Š„s‹{™}–…l…ˆ€ubl}ƒšœƒœŸiXs£y„™v‹‡dqT[kr€˜kx†t~j™‰cxnn‡\u‚nhf~}—{okj‰sg“‚oi¦‰‚Šw…Y‚–k`|‘†jˆx€q»ƒa˜yƒ¤R^›lq…Š‹xw‹ƒnnhvŸ~qabwr€ydOpƒUŠ“ƒq‡b‚|ut“Xsr–ƒ…j…„e€ pu–bp¥…i”ˆ‡Šuˆ•lƒ’¥š\ji—y€u‹ux¡‹”ˆy[„mf{x—e…—rÈƒ‹uŠˆ–‚sz}”Â‚{ ”ˆÉ„Ÿ}w{“—|‡v‘l‚€r‡R{ˆ…˜…‘‰vkYt‡€ˆ{™®„ˆ‹‚g˜~u~€‚–syh’™›„”„²²—œ¶R‹’ohŸu˜•U‹|cn†x”oƒ•™›‹˜“‰Ÿo›‚¦Šx‹p…¡ˆ…pK†Sm—Št³v|ohˆ{†wuŒzd«…Œ™Œšt±“mmv„“}€ƒqZƒ«Šƒpf“¡š|wd—‹}|¥ppu–o•^”Á§…y‡¢ya]ad†}nˆšr–bkƒ…š—yb}o”u{z~g’t–••s¥~šh€mnf‘pb‹b[pw~pzi~œ‚€u‡QVioppn\€U{„ ¯¾£qwBc}PrP~Œpª™[˜šƒn’sy_e‘““R›¦t„Šm…Œi‡xŠ•nc~˜‘p\q^ww˜`c¬qVœŠ‹h]‚‡{jeq†l„zxY†I^r¢X–Œƒu”–‡…dq\‡ œ„ƒƒ¬r|½œ’…„‹wty‚’¡¢}‚€ˆz‚mŠ’px‚­vV«˜˜„gv}tRŠŒI[—}™›§k‘Od€´‰[|«•…œª¦‘ƒhŒŒv– ƒ†xh–€{”wi†L‹“‚\e…~vv®„p`zwsŒ}Šyr˜|‘ŒxŸ‰‹q“o’›gpƒkec4nªz‡ƒ’‹euNw}‚—Z€Š¨¬ws‹x§hw•c”†ep{s{Š{rš©Œhex~l›X„‰yw–r…ƒs™…¬ŒT†j]zly_}x‚£mmCd_‹f”r‰´“~oh†deg‘{†˜l¥„£f°škŒm†d‘wx”hŠ‹‚|s‚—…n}`”l~mx„†•}~“x™–¨cl˜«a«‘ƒ…„}‘d|q}†Š–¥`E€±†§h”x…o–ƒ˜€N|c‘dw €[Y_px}w«|t–xpµˆ†‹ˆ^t‡w‹s“{…wzQ{b¥…m‹t‡›Ÿ”†¡ˆg~‹‰—wv—–®“„}v“ Ojƒy‹j“‡yns˜x–P—”xz¦lƒt{Š™–t—d›{m ŠˆŠ²ud^m}p¤b`r–”…¢c‰|•By—¨`±qŠ”·g©œkŒOœm~o’b…hrA‚Xƒf°y¶^©—f»“¥B§QWxpChito©o–w¥§Š€ƒm/lµ{¦¯‚ •vz„gnd[¬lu¨|z„Ššnƒo xEŒmXrA/•ƒht‚^›†‹Š¢n¬ˆ]kmŒbf”ro¯er[l¸Œ¤Š]­v}bL†sˆšmƒsw5i—cŠ˜~U¤{{v{~~¡ª¢z©¦xnqZ˜i‚f€˜ª| {†‘xb»y©s•N†hŒŠ¤€ ~€wusI„‰x†²sE‰c£¢7¦sx›}>aš’¦†~}jo_ŸƒLmr¡hlfŒ™e„Fw¦—Šty™»™|ƒr„kšq™ywl¡q‹mƒŒˆ¥ˆVoZW¢œ‚msokf|O^z‚{k®#M€mtc_‹x¤u”M¶_`ƒ|Ÿ—€p)iymomb”V”“ˆm=†E~dt’yh}q•P‰K¾‰™±}jyu‚–‰„J_xšrr o^œaš‡mpw~…¡†ŠŒ¡jvA€g^¢b[bQ|U}yÇ³ˆ•ack#usage} string
 */
export interface Row {
    left?: string;
    text: string;
    skipLine?: boolean;
    type?: string;
}
/**
 * A heading for a section in the usage, created by the jack.heading()
 * method.
 *
 * First heading is always level 1, subsequent headings default to 2.
 *
 * The level of the nearest heading level sets the indentation of the
 * description that follows.
 */
export interface Heading extends Row {
    type: 'heading';
    text: string;
    left?: '';
    skipLine?: boolean;
    level: number;
    pre?: boolean;
}
/**
 * An arbitrary blob of text describing some stuff, set by the
 * jack.description() method.
 *
 * Indentation determined by level of the nearest header.
 */
export interface Description extends Row {
    type: 'description';
    text: string;
    left?: '';
    skipLine?: boolean;
    pre?: boolean;
}
/**
 * A heading or description row used when generating the {@link Jack#usage}
 * string
 */
export type TextRow = Heading | Description;
/**
 * Either a {@link TextRow} or a reference to a {@link ConfigOptionBase}
 */
export type UsageField = TextRow | {
    type: 'config';
    name: string;
    value: ConfigOptionBase<ConfigType, boolean>;
};
/**
 * Options provided to the {@link Jack} constructor
 */
export interface JackOptions {
    /**
     * Whether to allow positional arguments
     *
     * @default true
     */
    allowPositionals?: boolean;
    /**
     * Prefix to use when reading/writing the environment variables
     *
     * If not specified, environment behavior will not be available.
     */
    envPrefix?: string;
    /**
     * Environment object to read/write. Defaults `process.env`.
     * No effect if `envPrefix` is not set.
     */
    env?: {
        [k: string]: string | undefined;
    };
    /**
     * A short usage string. If not provided, will be generated from the
     * options provided, but that can of course be rather verbose if
     * there are a lot of options.
     */
    usage?: string;
    /**
     * Stop parsing flags and opts at the first positional argument.
     * This is to support cases like `cmd [flags] <subcmd> [options]`, where
     * each subcommand may have different options.  This effectively treats
     * any positional as a `--` argument.  Only relevant if `allowPositionals`
     * is true.
     *
     * To do subcommands, set this option, look at the first positional, and
     * parse the remaining positionals as appropriate.
     *
     * @default false
     */
    stopAtPositional?: boolean;
}
/**
 * Class returned by the {@link jack} function and all configuration
 * definition methods.  This is what gets chained together.
 */
export declare class Jack<C extends ConfigSet = {}> {
    #private;
    constructor(options?: JackOptions);
    /**
     * Set the default value (which will still be overridden by env or cli)
     * as if from a parsed config file. The optional `source` param, if
     * provided, will be included in error messages if a value is invalid or
     * unknown.
     */
    setConfigValues(values: OptionsResults<C>, source?: string): this;
    /**
     * Parse a string of arguments, and return the resulting
     * `{ values, positionals }` object.
     *
     * If an {@link JackOptions#envPrefix} is set, then it will read default
     * values from the environment, and write the resulting values back
     * to the environment as well.
     *
     * Environment values always take precedence over any other value, except
     * an explicit CLI setting.
     */
    parse(args?: string[]): Parsed<C>;
    /**
     * Validate that any arbitrary object is a valid configuration `values`
     * object.  Useful when loading config files or other sources.
     */
    validate(o: any): asserts o is Parsed<C>['values'];
    /**
     * Add a heading to the usage output banner
     */
    heading(text: string, level?: 1 | 2 | 3 | 4 | 5 | 6, { pre }?: {
        pre?: boolean;
    }): Jack<C>;
    /**
     * Add a long-form description to the usage output at this position.
     */
    description(text: string, { pre }?: {
        pre?: boolean;
    }): Jack<C>;
    /**
     * Add one or more number fields.
     */
    num<F extends ConfigMetaSet<'number', false>>(fields: F): Jack<C & ConfigSetFromMetaSet<'number', false, F>>;
    /**
     * Add one or more multiple number fields.
     */
    numList<F extends ConfigMetaSet<'number', true>>(fields: F): Jack<C & ConfigSetFromMetaSet<'number', true, F>>;
    /**
     * Add one or more string option fields.
     */
    opt<F extends ConfigMetaSet<'string', false>>(fields: F): Jack<C & ConfigSetFromMetaSet<'string', false, F>>;
    /**
     * Add one or more multiple string option fields.
     */
    optList<F extends ConfigMetaSet<'string', true>>(fields: F): Jack<C & ConfigSetFromMetaSet<'string', true, F>>;
    /**
     * Add one or more flag fields.
     */
    flag<F extends ConfigMetaSet<'boolean', false>>(fields: F): Jack<C & ConfigSetFromMetaSet<'boolean', false, F>>;
    /**
     * Add one or more multiple flag fields.
     */
    flagList<F extends ConfigMetaSet<'boolean', true>>(fields: F): Jack<C & ConfigSetFromMetaSet<'boolean', true, F>>;
    /**
     * Generic field definition method. Similar to flag/flagList/number/etc,
     * but you must specify the `type` (and optionally `multiple` and `delim`)
     * fields on each one, or Jack won't know how to define them.
     */
    addFields<F extends ConfigSet>(fields: F): Jack<C & F>;
    /**
     * Return the usage banner for the given configuration
     */
    usage(): string;
    /**
     * Return the usage banner markdown for the given configuration
     */
    usageMarkdown(): string;
    /**
     * Return the configuration options as a plain object
     */
    toJSON(): {
        [k: string]: {
            default?: string | number | boolean | string[] | number[] | boolean[] | undefined;
            validate?: ((v: any) => v is string | number | boolean | string[] | number[] | boolean[]) | undefined;
            description?: string | undefined;
            short?: string | undefined;
            delim?: string | undefined;
            multiple?: boolean | undefined;
            type: ConfigType;
        };
    };
    /**
     * Custom printer for `util.inspect`
     */
    [inspect.custom](_: number, options: InspectOptions): string;
}
/**
 * Main entry point. Create and return a {@link Jack} object.
 */
export declare const jack: (options?: JackOptions) => Jack<{}>;
//# sourceMappingURL=index.d.ts.map