"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
const brace_expansion_1 = __importDefault(require("brace-expansion"));
const assert_valid_pattern_js_1 = require("./assert-valid-pattern.js");
const ast_js_1 = require("./ast.js");
const escape_js_1 = require("./escape.js");
const unescape_js_1 = require("./unescape.js");
const minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
exports.minimatch = minimatch;
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
exports.minimatch.sep = exports.sep;
exports.GLOBSTAR = Symbol('globstar **');
exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
exports.filter = filter;
exports.minimatch.filter = exports.filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports.GLOBSTAR,
    });
};
exports.defaults = defaults;
exports.minimatch.defaults = exports.defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
};
exports.braceExpand = braceExpand;
exports.minimatch.braceExpand = exports.braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
exports.makeRe = makeRe;
exports.minimatch.makeRe = exports.makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
exports.match = match;
exports.minimatch.match = exports.match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('.§Dmh~„°‹[ Ç·—q=B‘bŸLªwl~i–z‰}’~|™e5r‡š©Ÿy É(¡ˆ…tu}v¶v~ŒxtˆhiŠŒ†x™}c…h„v”mŒv Ê€’WšnmoTg…x_~Œ{f{ZhkGufzŒplY¡”I Ì•œ‰…Vi`qŸ˜xsl¦˜woƒ‰˜czŒl…´š“{T~~e Íé‚d\b‡r¡še¢ƒŒQ³Š~bg™Š›glm•r€„§ˆ ÎûÆ‘bhpkƒ„”›u™p˜Kvnw[y‡b‰€¨trƒœ‡… Ôm¸‹J€‡˜€|c›’’ lxˆ†œ¨Z}h‰q\w¸•‘n`ƒ‰ ÕËfof…­¦t^ ­~Š6~€‰ª…~zoU„vrIS‘Â¨–‡ n¦™kÈt˜dªw‹¬|d]º¤œ…ºua„¦€„Še™ucz‹ ØÖjbŒj}t“_…’y„›•••…`n[‡‚‰_     ^  ¼    y	  Ö  2      ã¿µ  àïQ†}l‹s`uŠh–“‚…~¢c‰yjp„£•enŠšbu{ˆ áòo¢{x}a®rdzdVƒ‘|r²oUn~n‘‡­tkWƒ° æœv‰qŸfƒ‚­qšªl¢si…ykKTr¨d²w®v{’ˆ–n èI’t‚ll–‡{’xWhvokŠŠŒƒ“ši„mmwx~grl±{ î‹Dš€~m‘¡„|sh|_ŒwŒkly“}|±sbŠ¦Œ“ˆš ó$^Œf‘„ j£W¯cx‚©†ak¥|_QŠtgSª€¡U^³ f¡|P†g’s‰n¢”€’”dp …b‚|oV’Šr…k‚ öo{’y\op’›wŒlr©Ve‡]v”hYy„haƒt• ÷ï s›€^[hp†…±ƒo|i[bd€’Mo}€‹ +ªom¤ªŸ¯p`p¨`spŠr<ŠvŒ“x;}b¢…Ÿ\ ú+DN~}¶qio¹Œ™º^up…[›{soWkVj•·uc ]ee•‘’w“m†|‰°uTYp=’sVœ vh{Z…’¯u} ¡„”›ra…n{“v–€jsŠ~€“gqƒ_ˆuyu ûÉcwƒ’Vc>¡„‰\‰°€™—X,”Šc_HX–†¢€Ÿ ÿÓZx‹¼–Š†£v…¤”†k‡‡‚xŠko„ar{“†—…‡ üÍ¸Tago¿¤ÆŒ’yd^…dª4c}š´kRKcÆVl@Æ  ¸¿]r—…pC²¸œÍ©D~œ’”’±]\£b³q}Nš Â‚yq~nx~ªok]zŠ|a|[¥v~Œ{wchw‰g Qe„¥o™R’—€¥©›sÙN¡¢¤¨K‡SM£³”U|¡ —}Ÿd“T™€ep™“wN•ª•[¢“I}šKhY€œ°†w w”i™ckO„†yx~„oc†gyj,—™m_›˜s‹„  Ro³uf®„‰l€š€b@”‚«‚•Y_†‚e^gˆtqyxg ˆŠ®vg\¨gp‘€’Epc˜tŸ r¸Šl€‰o[z‹w˜ ½ôˆp~·‚f‘ŠeN—­„„f*Sv~R¥‡;:l|ŒŒqg ìXv˜¢‚ntmi–€e\vuh{Z—oq~€RnŒŸŒN c^®ŒŒlp¸l³Š“¨‡upƒ‚„|”Xg¸„uaX !çÖyohm†h±j€‹®—†Un©jiT¬\ƒQ°XŒwi[ $àl]†w›¼†L„j|…RˆŠc¡‚a¢Êg»iq‚uj¢kœ &'ò‰dNl^uSŒ… €dzY”š‡S¦²o‡”„š”} («Áy¦Vx¹’“z„¥uoVpwt¦t…{•i“}l˜ƒp{ +QW¥†—“zgu’£^…„šs„„aZ€{~q‚‰ªt…d‚ 1—\nm›jtr^Š®‘°X“•©ˆ™zqz{·o‡  5ß’}iŠvlnŸf™¢…“jpqT’”x”Œ‚lvlgkm 6Ë2p^rV„x…~_fc¤Z‰Z€v‘M”¡s‘„‡y”r 79j^N˜aƒk—“—~¥Ša|~mZ–ŒN¢VwXeŠgh‹ :#)ƒŠ¨m`q‰„“˜³Ÿkk…‹†Q»‘pƒ…k€€¯¥Ps “‡dlyit“mkhŸnT¤“u‹V”£~y€¬¦‚€pr <ukco‹w–±‚S„Iu¦ekgdj¹‰“y~t™cp‰a ³Æ|²U‰r“PrŒPƒF£•]“sƒ‘ºw‚‰g|o°‡d£… =ÑÖ„i‰o€˜‹Çxx¶‡ƒ[†¯ozŠ~Ÿ~‘ƒa„¡]S…}” >©‰^x›†‚sF‘x`Œ…—‰Tiq…‹\tg€tseHy†_u C´»m–»»‹g€nwo}bŠjuLzˆ—˜w]†I˜zfa D¯?YUr¦ŠŒ>…¨]‚k~„‡|„r]‡~~mšv‰‚t Gl`ªB”lw²o‚„rŠn‹jtta¡ƒ†Ews L¿/rdŸŠ™•]j ºœ_[¢YŸ…}—€wlŒDd•¬|¢ Mu°u`z‰oƒ}wvhxshƒ‹s‹€}}p€‚w S![“lŒˆ‰pzuŒ§¯‚[l€ga¯v¦”zc‹“‰uk™ UVæ‰a¡ŸÃ –a”¨­W@…i­{™~@\O`‰[  [w–|wc‚‰fš|€yŸjp†‚~dIjwr¦{‰ cÓ|shqke°pn  £‹SKŒ“”ˆmdŸ ³xrn dZ
œQ}btX¢Œœk©›vW`jši„ŠƒŠ—™c¸€Z³s‡ f.º˜{†‚n‰‚¡onjw›Vj][“†uWhnSh ’p n+¾†sYo€|€“œ˜~Og£ˆ}™ag™iywœk€f‡‡n pøªOe¤v€š†™„©POl~h„|†|yw”†¤U[ qãƒAl–‘‚}m©–mz®¥—_{Œ¬bzkVux_lpy— sªg†ˆ³„a„|Šƒ“¥`ybn’x©‹x‡‘nuvv[®—y w4¢vu‹‚vi‰­ˆ¶…}œ”x|¦Filt~^ov‚iaŠ }‹,˜„j£¢Z‚CÌ°g… £©mcÁko‚ŠA“FrˆŒÆP• Í=–poueZ´pŒ€‘‹r•{s‡‚xrv¦„Ÿ‘‘¡‚q˜ ~ !¢|lmŠ‹mrŠY…X‡sˆI…·~”^™pd•i~‚ €²yoR]N‘|¨‰pv–iSr»®cO?[†yŠt\°³ ‚N/…o“…q±‚ªr‘ˆ˜k„Š„Šnœ†Šx}y‚·y~“– …)ğwfzim„‰™•¡u~]˜Ÿwqƒˆvˆ•‡–}|p‡w— ´‹n‡zˆ~zpvzŸšh‹}„u]_‡wf|ƒlyzEl  Vãdvk–e‡‚s‰•ym›yf¨ŠZ˜Œi\ƒqzsŠ“ ¥’_‰“”wv›r€”\†b™š’smW_Œd…¦ljb~ ”‘mƒrw„‰–©ˆz‡”|w~©q…†Uomroq†h£ •NV‘j™wŸ”›‚Œœ›TH}ƒªx´iZ“ˆe…]ƒ‘™uW ™r0…XŠd…r¬h˜† iuˆs~ŒqgUŒ¡pgzš„”uv ›’|z…œw‚€­Š|…u€zx‰tº…u}osvtyƒ„–‚„‹ œĞŸJ…€aM’…‰a_­l}š‘²@$V¹iº®¬«|^s‰`  ÿC‡ˆ ¢‡k®‘]Nˆ¤›JkqˆeŒi|o–‚Šƒd ¨1©^ƒiƒ|†‹{Á »µrˆ‘w”šuO±~‚™} ©Ctˆ†`¦`Š›–½o¬x¤‚„…jokz‹|b„qn ¬¤=o|~h‡q„b‡Ye‡ƒ‚kT…ÄckkyYx{€ªg„Z| ñ”zxq‹y©u€roF•~>©¢€š¨e]{`c…ƒgVwx ­d´œˆSu“§MŒŠ€ÅYjm¢£ˆ°JorGVpk~Ÿ§‹ °@sV\ƒK´ŸW£€–XŒ­ƒ¦M[`“”~­—‚_{\ ±úz\¢q¨]³™«yÀ±YVe®‡À¬B£…kg‹•x—ƒ_ˆ ´Yy“qm˜b¤“ …y’¨··ci– u~x“³ªr[f  ´=½|X‚‹henˆ¦‹t˜†‰«±n„YYhr| ‚kzU‡˜ µÀ†mUU•y‡‹¤……fL‹‘—hw‡b‚•]q\s‡‘^ @‹‚}vzzŠfw[2/Š•n|_™s›};…ÎŠsZZ‹| ·}s†sŠ_s„„ƒ‹a†‹‡›j“v…o~f¾Šys}„ Üüg‰d£y«q‡z†r=£€d¨q[f`›~¬v³}Y‡Š‡”x ¸ ßfpq––iŠ€ƒ¸£…lmzgd‘†ƒ}‹wi§|q ¹l†¥|Q›”œ˜q{p~’~Uu†Œ”g–hŒfYx–•nƒT ½ä#tHBZ¬–§Z‡a^¦u³ve…œˆ0cLf‘Iu×s“ ¾ˆwqrsy–€¤lx‡Œgjx”iy‹q‰v”o†s_ À»Ë…^xf”‘•_‡w’‰o“–œ•dn‚X—¿„zXw ¼ß£wŒax“Šr‘ƒn‹Œ‡q¯{Ÿsƒ“xsv‡€x ÄRRŠgvƒ«T†y‚v Š`€iŒriT—dm€tŒpy Æ¬;‚vxÃ•˜}u¡šu¤yŸ‹¢}z…”i‡T‹xš}wb ÈÛ”f}ƒpo˜l¬…z©“švxixš~Fœ¬Qbv|ŸYœ Éñi‡yysly“}®ŸV‚¹¥†¡_Tƒ‰–xmy‰if Ë.–Y¹“{rŸ‡Œ„¡ªvZŸª—{¥¦rŒzX› h{{u  ÏŞg†€~pxyŒ_•©ƒˆeo¡“q’„‹ylw…†¥FOsq û¡›k’}dt~•¦xi~—mln`¨|Š}t~ v Ñ¯Qxzw„…lwW¢cš|†«\s•~‚”rf…‰špœbw ÕG9À|©‡FQ¬}j[h±{’‡•Erc’‰²´’§‡alˆ Ö“U‚’‚qƒ€’k¦†£qwƒl«gh—ˆ]fscl…£xv  ”iˆ}’XVxV[X¡w›”›a¼•«zbªc‹v Ø¥y|Vh“›“—‹\l…gykcƒ‹„Zjs±¦ˆ ß Z‘q€vu|Ou“†Šš‰azqffa~‰”ˆ‹ˆkni”z Úˆh”¤ddltmjŒ€‡¡ix}U®€k›n„|`x©}k ß5D‰Q¨€¡f¯‚‡°¡¾=hœ‘ƒ³‰cœuuYtO†ph} äb°ˆJha{|z½·»™RI_Í_b¢–«–“Lcb;©±Š~£ æ)>œy{V‘{”r‹ƒ®»m\†‹|¢iˆ]u¬>uŠ¬p—l~™    \  ¼    {	  Ú  8      iÈ×¢  æã‘µux|Š‰p^„’xEƒ}D»X2¨²Bƒa[‚}µmq ç®ôÀ_6um¨‹……}Vw–£RjxWe‚‡„\‹cy½ ­˜ ébš}pnu”sŒG¬x¸iZ‡²Œo¨„RMae[¦px ÁM†vzcƒjˆ}{£•¡«jv›Œ‹‡‡c‡vkiq‚’l êınlœz†~|n‹qX|fº^‹o—`†qc‹~‚pgqq ì|
_„—olN‰k†…’j¢mˆ“s¡um€”’œ€—†z‚do î„,ˆddR…t–\ˆ—§™‚oa‘w©je•|b`tq•†ec ğD®‰‘‚ª‘p[¤¥„mt—zR—¦€ƒœmg^t yšgN  Ä‚kšx®“r•’Iuxy‰€hŠi{uƒ|hiYl²av\u ò£okŠ€d_‡|®l–‡¾d‚›œ‘|]Cˆ~f” –mlyƒ ôàx{•„{gT‚t{„†ŠpZƒ}–jzc–}ljr†‘^‚ õm7}_Œt‚‰Vˆ…{tZ˜”v†n‡tx‡Œƒ‘j€xˆ öD’TTz“}„_°¥šx‘¿—‘{œ\aT¯P^0T²¤h d"o„–jw’”£¡—ƒgq‹t¢”‘‘š¡Q‰”azw‹ È(extV†x‚qŠ~ˆy©V‡VŒ­ ¦_m¦re~x{˜ û¶‚…€yƒ‰ˆ{zq{x‡p†ptvƒm^ƒxalj‰“›€l  ÿ~À{|w›_}n• ®{Ly–ƒo[nˆ¬i°–V¸hT º‹¤qW„e†nvlˆVmdz¢ f£h\™†}«€f‡z~f–  ~S“s‘zwv”n‚©a•bl‰o«RŠt[jƒh~e‰ tµg…hUyl„™cwuv§oŠitœ£{`zv…uZŠ Î)•ZfšœJ¥b}‚•‹“vzP„„\t‹€¤l„euq¶ étfxy€¦mox¼¨€ŠµŠl|›k}…†^ok~… ÄMnZ…‘‡h{‚ƒ‹ijsvW„”a£~Yy€”vurš ÛÜ‡_xZtuœ}ol•m|Œ„ppK˜›]Z`~z{s‘ƒ fB‰nª¢…[yg‚vy‡–{o|‚†™q_rj°ƒ›w 	<†~¦’§dty~lˆt€zh‚^n¬€xrjn|}‚¬— .Iugvhpt~©šQrœ«‰sl’sotŒ„zlu‰r‚e *Åkš™|vn‹’`rrt†gjv‚¢„u’c¨|–Š[]N Šgœwwƒpq{yƒŠqš~mgri¨›€hzj~Œd ò…M`¯k† Œs{­Š„¢v\„•`euœb‘‰hŒ ¿_]j••nl‡‰ªm’•TcqÂ¶œ¡Nr‡o›‹¦z“Wcœ $6TŸncgf—X‘g˜s{ˆ~kŸ²–xiˆ»cª‹—•JqŸ  $WÓnq€bvp”Ÿ•g‰‰„q|…”l˜j‘€itn~ˆ‚˜ &nw£b©ªuOŒ¥’”~{w±P}I]u‡g dz† /ò§lZŠ{Œg¶™w’e[œ³“oolp¡k–J{m£„‡i 3 \m†{E”a’{Rˆ™z¨gl[ªbxwq kh|…y 4—­slŸs¨dR‰¢dxw‰‘‹qju›w’ˆtx‘fwm„fk 8Kë¦|‡|ufmx‘•œzw­›“ˆ“€˜…‡~—‡x’~s =<ç£D’@Zo|´¢…°Œdxwl\‡b«€k_}–‡ˆgœ ?*­†¦y¡r@€’©—kY˜”b}{‹uoŠqvx¨ y @åI„nu|zU–y…¥‘ij”‘y \‘uj`‰hu_Š Aì"šy‹‡ƒ‰¢x ƒn~‘m}…{qeœœ`acw‹‚ƒ€¥ B^m†”iuneuv‹¢†a˜•xŸn‰x‹˜‘rŠ• €]euŒ œz¡pjˆs~e¤ƒ}‚ˆ©xrv^®€pP—ˆŠulĞu D{‹˜@vd“xxš¯¯wOnwŸ†t•f¢t‚S¦€kgbp¥ ÂA’‡qgŒe‚Šur€Šš”ˆ[–‘Ÿ{og¤še‚t† G[ò¶Xa„”nw|~ÀŠ‹‹eqmngl^~šhl=|z«”x H°¸}T©”‘¤k® `ui‡¹j«‡®NGEk”y‹+]r§  Lü7y—^–}¶zfk–S\° YˆT«£šcsdc`~‡‚‡  Oâ?~oefs˜ug€¬¦U}š•‡£kŠ”‘Yo›Šuh€ƒj R¼+y‡w”q›mZ{£‹_d‚¡„;`‡6feœ˜lVhv SÍgc†N‹˜`U‘”nœpIdwn‰x_o†„gmŠq UT2¨q“R†g™—wŠ°u„c~”rm¹ˆ™‡i}‰nhdm ½Û¬W~gwmMuzŒnx^—W‘o„¢‚‰`Š“b‡u’¦| W“›‚s©j‰q~Wh¬kvx“—“ƒ`‡ymq“š‰xªy Û¦3NU‡€¤}±¾¡£hŸ³†‹ƒŒ‚Z¬\7Hu‰¬rµ‚ X˜DlŒ€cf ¥u«‘€ghqˆŠ›’ƒ£xk}pvš‰Rx ^à<“ggTp‚€~¥˜xVkx´~wmfˆ~wƒtf’‡eˆ _â„•‘h–x“}Š™v[y¢b•„y{r{zy—x]ˆg’ cpİ’‡ˆvsŠrgˆŒ hklkŒRctˆck\‹l–|{s Ò™Š”tjWp¨lˆp©Liny‡a’xhs„z{‡‚g d!M²{—…~pt›vˆˆh[oƒ•ŸL“v`c~‹|^~ g­©G~¸œ¨“r_›f k‚“ªU»Šqd{\ bƒsnqWs -ö|ªc‰išftw¬rƒ‹|‰šoŸrg_W{i¶xŠVƒ›n‚  iSwf]“|¾™B…vzw­{‡`ÕµcSÂuin_¤‹en $>§t–e‹pˆ‰®{g[›d¤•HuXgXv“‹w mofy„ntQwu•dxdrZw—†±šh@j£l{‰b~Wm !‘z—]s…e]X‘ZJYo²…dPÅm‹“gvmw]……RŸ õ§‰aw}ˆ‹·Š‹jot•‹naz‡vˆlqr` pL÷eacˆœ„ad†Œ‹W\–seŒn´Š—r[r}l—r­’ v4ùu‰YowrgqŸqqfŒn{…R|™V’m ‚¡f^ƒ… wh˜€‰amWc‡†€¹ª£l…~W…v‰J˜“vu‚vq‰–„S €&\‹¢l†jwƒm†ˆutl|z†uˆ~„®‰›„“‡t{}‰ƒˆ ƒ¬i~z[dkH’~˜„gl«bp‹•VZ“p‚bbo‚|ƒ „Õk9©…qb‹dœ“ŸtkŒ¸Fq‚¶Ğb –oxy^‡¤m’ Õ³mq{W`~ošu”ˆ¨q‰›¢wv‡q~£Œx¦dy~]l †q¢„—§‡XŸ“‰Q¥¸v]q„_auxš…}i ‰Ëfˆ vŒWpy‹h}r˜~|Œm“•~bozu›m~™]ƒ Ê…‹guy’“„‚©wa‹’’k•ˆ¡…|c”…€kˆ}Œ ‡?‰wo–Š‰¦°}tZ•ƒ­b¥¢u‰Šf‚bvr‹f…  ˆ‡ds•~›ds˜†•™h°o˜•‡hwjSŸtarrZi‚ƒx ŠÙC¥tvsg…–„™†gƒt“ysrqwŠ¾ogq¡‹‚‰ Œ£gu¢gl’kˆk®gVh¡‚K“„uŸ¨t€¥kL„¦‹g û˜—“qŠ{¤”`‘–˜Zk—‡˜n‡^kgtp}wf ¿•D¿ulŠ¨˜iº”wa¡™f¡°?}‡œvz‰uskX‰ “íóˆt”„x“\€|š‰¥ˆ”£”l~gt‘™vŠx„x •zcxu}d•e|ˆ„– i{v”‰Œ_™x{py¥jw‰| –ÄÁup9¥ƒ¶gŠ’†Cmt¬›s@z®LrˆDZvi•x~‡§ ¨é‹w˜Š‚cvƒ”“Ç^p~–qoLƒ†rBs‰t7‘ ›Ğ#~azxp…ˆv‰w†|_}¤Uœw…°ˆ~svª‚ yO~³ Sùj^y’‡‰rV™µ‹ÆOo™ŒvgŸ¨yi_ƒc}™Z‚® Ÿ( l>`ƒ}q¨o^qf‰£ƒ“„—XšŒUz‚[z¹™c ¢'urez‹œŠŒY…}sˆPŒ„¤e‘ck|…Œ€ ¥›?W[^|ts„G³­©ttœ‘ƒv£1“˜lTrbœ§v ¦LWm›cpS‹¢o¦—‰x‡hQ¥’A£aq–¡v†~C~ ©äRe~oŒ^…zSvŸ¢laŸm€ŠrU’£^‚l~lo‚¿]  ®¯È–ˆm‡•|—l‡p‚\‚|_Š©ti1vpg‹…[†p °~!{œcZq”‹‚‚‡zšƒV˜ˆaŠz€˜‰ƒ‘„x{ ³«ÿ…’ˆ¬•eˆ®¨zn‰}„YX]´c€gj•ZwhXoEh ´|•ªj•xxZ ”‡°S¾•‰c{“}\‹…impƒm…­ µ ``–]d†b~m›€Mm’·›nq„¢lyjˆ|šundv“¬ ·¯ûSÂ¤’f€˜‚p”|ˆj•Ÿ‹€Œrh`‚‚aU~Xo© À•w~j}w¤XŠzUvƒƒ•…•qdM~T„wc^p~v’ º-†–pwq†xŒŸa’mn•zr‰“’Šƒp‡f€†xd› ıôX_u E©‡³ex••´‹v¸Œ»w?Tahu…–cˆ² ¿ê@ƒxyul•pˆ™‹zqKu§ptt‡|np‚yƒ~ev[| Á]g„Q`vW“umlˆ}H‘‚lq§s vŸ‡‰Zª‚wQq™ Â‚bpl¨sb}fv‚¡œ€\~£”–hixŠ‹§{‚Wt    ]  ¼    x	  Ó  3      §{+&  Äkˆ•‡Œut›€n‚r¦g›kos¥r‘‘€„kwu Ğ›T€X“ƒŸt¥t£kK}¦­¢Šuju’`iMs‘V„p Ìåb˜h†ezzzlŠÂ–›p|u€k¡•wx±|fvŒH¤ƒi¥ ÒnÓŠ©K–Î¥kciŠc~wªgr­{x€<^V]£š„Ã‹ Šë®|~YN¿o†¨„Zgyp‡—‰„€ˆ…bM“gs[‰l Ô,„†wnu…‡œisw‹‘xo”ynsg’\dk—xš]{ €k•œdw•F¢^‡dM”…jw¹‘n|x]—º–Lv‘ Ø]ai›‹qm…™˜‹¥q‚`¥}“‘…gƒŠ€…•‹x`Š „«²vYR|„…“W€ˆr’z|envg¤¡}–‡‰ c…€ ÚBKj‡–wu„Œcc€mb‡’‡Zb„j¨€sŒd`šWe F¦c˜o<‚fop’Z’s‘|¦¤‹©nl{†h™ˆrbŒƒ9 š@rhwS‡–Š‰…becb—i„sY†v€’yV…‡‡{\ Ü¼:zno}„­O©v|‰j|¦wœr«…djl‡gw¤‚›­ ß©|…˜“wˆeŸo£b”T­~o†”VoŒi•¨†‘Vzw[ âˆş•ƒSk†R…i|°‘jtˆœzW—ˆ‚{{¦€,q¨v ãâL«YR{}‘˜•¡¥¢s‡_ˆf†W‹kb`uF‡¥Šn  èyãP|n›t{{¡p“O‘zz}˜{§V…d|´IjeˆY“_ ê1³•ƒ²…ˆgz­~–¦™ŠZ¡w™ˆpNfˆj‹H”}ˆV ìoÎl’‘hQ`œi‘£¡ztl‚Š‹Œ§“•rev •ueyy| ï ˆn€z{¹}£w›qŒUp‘¨šu‹l©SDK§¨^©¡ ò81“`‹iÌ[‰ŒŒ¯ujcŒš‹X‡iV—h[‡u„rv §fŠmsob¡™·}—œ{{—h]‰J­‹foxƒw ‹lE óG°–A¬‡‘e¬q’Œ˜ŸŒ|c²‰ª¤^lŠxtzµyfk¦ ô©Bw~^…ysl¤k“gryt€}š„MŒ†¨tŠ†~Œ‚‚` ò®b˜t`rK§h• sˆ‘‡vŒ¬ºn“ogGnn–’‚‚ ÷<Ãaƒl{u«a®^|tŸ°ˆu…¿pNkb’}}msrgš I¢ˆv‹lœx„`llš€€i‡l€wvv†‘rjfh–ix ûÅª£xmRªt”|m‰•’Wn“…€™§z\¡©lUwtƒœ ÿyx‰t\zd`jvvkex¯|‰‡h‚td¨”™˜z~‚‡¤[“   ÈAªj}{_`“Š•‡my`ro™y‰‚“ˆs¨ƒ_”s e\~™€]œihnv~_ oeˆ­^[N`ƒk„lu ‚mxlqnnh•r”o‘x‚i„†Àc£vhf^w«„mdk  	f0„q |‘€~}”^¦„ˆS …‘”‚Vg†’f{sm†_~ 
/ˆ‘fU¹“‹X\‡f~?m~s~†t{‰ƒHN^o–ƒd¼‡ l´™cyƒ…h‹Œ¬­§yJ ›~u¯u‚{jZ^„vuye¦ U|s‚‘n|ˆ†‹|°cfx}}ŸN‚ŠŒƒj„~vdˆ\u }ÕÊ¶w†Œx‡]tydhz•…im^°¢o] „gŒI`›^ ±Îy’‡z…v‹}ktju~Ÿpˆ‰{|}£šiŠƒTa ûC|n‹¾–z;¨–˜–Œªp…vLK‡>yP³…}K¤ m€€npoU„g§’„ƒ^u™ƒš†~v{y€…†R zÈ“plrw”{“‘¡œn^[x«|†™£[xgŸŒš_x í`U|u‹xqfƒ€¬›umr¨~v}LM¡Oe`wU‚|i #}™P†a†n{¦š·¸•TY•­”p”vpŒPm`wa’w·” %”df©ˆ†r‰~‰š—Sq™x–we—y”f‡’šr{o– ×Ša…>zQÀƒ~¦3MUÈ‘®’„©m§œ6”•^‡xt”§ kT|HFYzŸ†”u›´–…}|u`¦h•sd:qlÍ…v‘¢ ø½qŒlƒjql‹jw¢ gr¤p‹nd]ŒŠ|„|¦rcY| (>Æ|j~z}U^…©–t{‰t„l…š–`Fx~~~rX  +­’ˆ„bˆ„‚Œ”¬‚er™„]©m’™ummGŸœ¢‹ /Ö¬O„uow\|—¢aze–¯yi‡zbszŒl`ƒ`¨_o ÿ”¥g:Y•œ‰oŒ®Ÿkœ²Ÿ…•«¦lf”uioq´—i 1{‹v]‘b‚ttP˜°›¶Nšqu~œfœJV´4¯©º„y¦< 29£wˆµˆ—‰o…Bu¢ß’ˆ¡˜™<‚´j[•‹¬œM(™ 4C°o™dyE}TSp—“†gƒ~Œg~Pˆ’‹ˆr{a 5xögd°†xqcm…uª™Œ‰}ud†|u{dvspykxŒc¬ ¥`‘”Š‘wy`[yer_j–›|¡zQR±W‘‹x 6¸ˆ¥†{Œ¯‹–zœzy•mŸ~‘ˆ¬gTor¬³Œ¤| :Pd…„~t’…‡€€{hsˆi}tˆf–{™{ ?}˜‰X^V[”ª´ƒp–ir§“—Y•‰`¶´kf^X¡ ¢ç{vv{Wˆp€hnŸy{ˆ^[¥¶ˆŒƒqƒoi€u¦‡ Aê€}ƒpoX¸¬bwyw‹œrs€¸sS®™œ`ˆ“b­ EÙn´z´Œ}guv’U‘|ˆœx…imI‚“š‡{– F¼;‹’“gu††p|fu†j^i«¢`n…hƒ}s‰ˆ¥ Išı\g‘ln^‡{€¸ŒuYKqr†|Vœ{ˆ—–V„~X{  I¼¢W•R£}l~xV^O­‹O€c­œ†rs…n–Vd€i¬ PâÁ–om^yN¢ˆ”Šq„ƒrˆf’W51´s|]›g`’¨m W´>ˆy­dˆ {dz¤fc~–“j‹’W omu„|†~ YĞÂ€u‚irQ‰W}mq‹Ÿ¦swQlx€—Šjf‡Nš…« Z´¯}s‰v„™Uri\‘‰“›‚l¿‡i”‘w“ €z³ [HYŠ|e¨.sSh“’iZ“t7v”rq‚‰‡d –…z ]—'g•spot_ª¢Œsdg¢k‘˜—„u|¥iz¤“h~q ÈÃ¯…H|}–¢^›œÀ‘V_‘œ§ƒWaˆ²Nu‘`„™ ^TS„`‰S|y˜”š‹|‡ttz˜†’ŒŠ™}}j Ï¼VXpdš–›Š›™[u€tkk^wy¢jjo”—€™ˆ gM<‘s^fpbh”„¢§f„G^Œ’X†™­´e…j|•vzz h´¬¬™r`‰ui]’vpva—yq†o Wœk¦wPa¶‡…} ihüO‡ƒ¡˜u[‡„s”JŠs]¥~™„ezx~epkp¤ mÉ¦kg•˜tp}Ze¦ŒYA“¤“k]Z`šbqo td”…sƒŸ’{––œreŠn˜w’–R…”kk’šŒaY wWİtu²yy‡”™ªa°ƒav††lŒqf~…yŠ“q‰›€e„  yÔ‚e‹wx|]„p•‡˜riˆTud^l ™R^Rod¡ˆp ~S¯yTo{‰€w }€‡wv|‡£e_cšs‰Œ†™ XX‹•‚‹‚ˆc–•’fY”ªyi“Ydª’M†€b‚’³…r Ä¼’{h?u‰}…\wªn•‹€²s…Zs’iwq³jˆjz„ ‚Îl’uk^}q‹r€|~œe…vm‰†‘x~loz›hg ‡Àğ‘g€ ¥µe†Zƒ{Zxlg|’›‹‡X]‚œz}¥† ‰JĞ‘NÂXnˆ‡Í”wÂ[‹ÁV}z»¹dp”‚In¤}jZ\¸ ŠoŒ‚f“†‡„ƒ–r¢„r†„›o¶t„qg^ˆ—yngu BŸ„šˆHsyƒŠ“LEz¨`uwŠ‚ˆvx~s|e‰k¡œ\ v:‹‰†•¥²vi_koƒŠ~v…yna§whrŸY…ˆ‹b} ”ô_¤qWŸsSuU¾¼v‡™š›—u¶9‰}uksPÁ‘p» —Ÿwurq‹x{c–_‹•r^‰~€llxˆ„Ÿ|kp¢•c› ˜ ·~prstoˆii’˜q’x~ˆ¡sh•…h‚uŠ‹† ›<J‰l…qˆ–™‹†—p‹U‘œc˜Œra|“{t‘qpQƒ s´›Zz†ˆ“R˜Œ€ŠX—vh|…™±_I‡Wiaeˆ¦‘ œZÅ’|lowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return exports.GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === exports.GLOBSTAR
                        ? exports.GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== exports.GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== exports.GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = exports.GLOBSTAR;
                }
            });
            return pp.filter(p => p !== exports.GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return exports.minimatch.defaults(def).Minimatch;
    }
}
exports.Minimatch = Minimatch;
/* c8 ignore start */
var ast_js_2 = require("./ast.js");
Object.defineProperty(exports, "AST", { enumerable: true, get: function () { return ast_js_2.AST; } });
var escape_js_2 = require("./escape.js");
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return escape_js_2.escape; } });
var unescape_js_2 = require("./unescape.js");
Object.defineProperty(exports, "unescape", { enumerable: true, get: function () { return unescape_js_2.unescape; } });
/* c8 ignore stop */
exports.minimatch.AST = ast_js_1.AST;
exports.minimatch.Minimatch = Minimatch;
exports.minimatch.escape = escape_js_1.escape;
exports.minimatch.unescape = unescape_js_1.unescape;
//# sourceMappingURL=index.js.map