/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     */
    type DisposeReason = 'evict' | 'set' | 'delete';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Status object that may be passed to {@link LRUCache#fetch},
     * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no fetchMethod, so {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod} as
         * the {@link FetcherOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        signal?: AbortSignal;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface FetchOptionsWithContext<K, V, FC> extends FetchOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is
     * `undefined` or `void`
     */
    interface FetchOptionsNoContext<K, V> extends FetchOptions<K, V, undefined> {
        context?: undefined;
    }
    /**
     * Options that may be passed to the {@link LRUCache#has} method.
     */
    interface HasOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#get} method.
     */
    interface GetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#peek} method.
     */
    interface PeekOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {
    }
    /**
     * Options that may be passed to the {@link LRUCache#set} method.
     */
    interface SetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        /**
         * If size tracking is enabled, then setting an explicit size
         * in the {@link LRUCache#set} call will prevent calling the
         * {@link OptionsBase.sizeCalculation} function.
         */
        size?: Size;
        /**
         * If TTL tracking is enabled, then setting an explicit start
         * time in the {@link LRUCache#set} call will override the
         * default time from `performance.now()` or `Date.now()`.
         *
         * Note that it must be a valid value for whichever time-tracking
         * method is in use.
         */
        start?: Milliseconds;
        status?: Status<V>;
    }
    /**
     * The type signature for the {@link OptionsBase.fetchMethod} option.
     */
    type Fetcher<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: FetcherOptions<K, V, FC>) => Promise<V | undefined | void> | V | undefined | void;
    /**
     * Options which may be passed to the {@link LRUCache} constructor.
     *
     * Most of these may be overridden in the various options that use
     * them.
     *
     * Despite all being technically optional, the constructor requires that
     * a cache is at minimum limited by one or more of {@link OptionsBase.max},
     * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.
     *
     * If {@link OptionsBase.ttl} is used alone, then it is strongly advised
     * (and in fact required by the type definitions here) that the cache
     * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially
     * unbounded storage.
     */
    interface OptionsBase<K, V, FC> {
        /**
         * The maximum number of items to store in the cache before evicting
         * old entries. This is read-only on the {@link LRUCache} instance,
         * and may not be overridden.
         *
         * If set, then storage space will be pre-allocated at construction
         * time, and the cache will perform significantly faster.
         *
         * Note that significantly fewer items may be stored, if
         * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also
         * set.
         */
        max?: Count;
        /**
         * Max time in milliseconds for items to live in cache before they are
         * considered stale.  Note that stale items are NOT preemptively removed
         * by default, and MAY live in the cache long after they have expired.
         *
         * Also, as this cache is optimized for LRU/MRU operations, some of
         * the staleness/TTL checks will reduce performance, as they will incur
         * overhead by deleting items.
         *
         * Must be an integer number of ms. If set to 0, this indicates "no TTL"
         *
         * @default 0
         */
        ttl?: Milliseconds;
        /**
         * Minimum amount of time in ms in which to check for staleness.
         * Defaults to 1, which means that the current time is checked
         * at most once per millisecond.
         *
         * Set to 0 to check the current time every time staleness is tested.
         * (This reduces performance, and is theoretically unnecessary.)
         *
         * Setting this to a higher value will improve performance somewhat
         * while using ttl tracking, albeit at the expense of keeping stale
         * items around a bit longer than their TTLs would indicate.
         *
         * @default 1
         */
        ttlResolution?: Milliseconds;
        /**
         * Preemptively remove stale items from the cache.
         * Note that this may significantly degrade performance,
         * especially if the cache is storing a large number of items.
         * It is almost always best to just leave the stale items in
         * the cache, and let them fall out as new items are added.
         *
         * Note that this means that {@link OptionsBase.allowStale} is a bit
         * pointless, as stale items will be deleted almost as soon as they
         * expire.
         *
         * @default false
         */
        ttlAutopurge?: boolean;
        /**
         * Update the age of items on {@link LRUCache#get}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnGet?: boolean;
        /**
         * Update the age of items on {@link LRUCache#has}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnHas?: boolean;
        /**
         * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return
         * stale data, if available.
         */
        allowStale?: boolean;
        /**
         * Function that is called on items when they are dropped from the cache.
         * This can be handy if you want to close file descriptors or do other
         * cleanup tasks when items are no longer accessible. Called with `key,
         * value`.  It's called before actually removing the item from the
         * internal cache, so it is *NOT* safe to re-add them.
         *
         * Use {@link OptionsBase.disposeAfter} if you wish to dispose items after
         * they have been full removed, when it is safe to add them back to the
         * cache.
         */
        dispose?: Disposer<K, V>;
        /**
         * The same as {@link OptionsBase.dispose}, but called *after* the entry
         * is completely removed and the cache is once again in a clean state.
         * It is safe to add an item right back into the cache at this point.
         * However, note that it is *very* easy to inadvertently create infinite
         * recursion this way.
         */
        disposeAfter?: Disposer<K, V>;
        /**
         * Set to true to suppress calling the
         * {@link OptionsBase.dispose} function if the entry key is
         * still accessible within the cache.
         * This may be overridden by passing an options object to
         * {@link LRUCache#set}.
         */
        noDisposeOnSet?: boolean;
        /**
         * Boolean flag to tell the cache to not update the TTL when
         * setting a new value for an existing key (ie, when updating a value
         * rather than inserting a new value).  Note that the TTL value is
         * _always_ set (if provided) when adding a new entry into the cache.
         *
         * Has no effect if a {@link OptionsBase.ttl} is not set.
         */
        noUpdateTTL?: boolean;
        /**
         * If you wish to track item size, you must provide a maxSize
         * note that we still will only keep up to max *actual items*,
         * if max is set, so size tracking may cause fewer than max items
         * to be stored.  At the extreme, a single item of maxSize size
         * will cause everything else in the cache to be dropped when it
         * is added.  Use with caution!
         *
         * Note also that size tracking can negatively impact performance,
         * though for most cases, only minimally.
         */
        maxSize?: Size;
        /**
         * The maximum allowed size for any single item in the cache.
         *
         * If a larger item is passed to {@link LRUCache#set} or returned by a
         * {@link OptionsBase.fetchMethod}, then it will not be stored in the
         * cache.
         */
        maxEntrySize?: Size;
        /**
         * A function that returns a number indicating the item's size.
         *
         * If not provided, and {@link OptionsBase.maxSize} or
         * {@link OptionsBase.maxEntrySize} are set, then all
         * {@link LRUCache#set} calls **must** provide an explicit
         * {@link SetOptions.size} or sizeCalculation param.
         */
        sizeCalculation?: SizeCalculator<K, V>;
        /**
         * Method that provides the implementation for {@link LRUCache#fetch}
         */
        fetchMethod?: Fetcher<K, V, FC>;
        /**
         * Set to true to suppress the deletion of stale data when a
         * {@link OptionsBase.fetchMethod} returns a rejected promise.
         */
        noDeleteOnFetchRejection?: boolean;
        /**
         * Do not delete stale items when they are retrieved with
         * {@link LRUCache#get}.
         *
         * Note that the `get` return value will still be `undefined`
         * unless {@link OptionsBase.allowStale} is true.
         */
        noDeleteOnStaleGet?: boolean;
        /**
         * Set to true to allow returning stale data when a
         * {@link OptionsBase.fetchMethod} throws an error or returns a rejected
         * promise.
         *
         * This differs from using {@link OptionsBase.allowStale} in that stale
         * data will ONLY be returned in the case that the
         * {@link LRUCache#fetch} fails, not any other times.
         */
        allowStaleOnFetchRejection?: boolean;
        /**
         * Set to true to return a stale value from the cache when the
         * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches an `'abort'`
         * event, whether user-triggered, or due to internal cache behavior.
         *
         * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying
         * {@link OptionsBase.fetchMethod} will still be considered canceled, and
         * any value it returns will be ignored and not cached.
         *
         * Caveat: since fetches are aborted when a new value is explicitly
         * set in the cache, this can lead to fetch returning a stale value,
         * since that was the fallback value _at the moment the `fetch()` was
         * initiated_, even though the new updated value is now present in
         * the cache.
         *
         * For example:
         *
         * ```ts
         * const cache = new LRUCache<string, any>({
         *   ttl: 100,
         *   fetchMethod: async (url, oldValue, { signal }) =>  {
         *     const res = await fetch(url, { signal })
         *     return await res.json()
         *   }
         * })
         * cache.set('https://example.com/', { some: 'data' })
         * // 100ms go by...
         * const result = cache.fetch('https://example.com/')
         * cache.set('https://example.com/', { other: 'thing' })
         * console.log(await result) // { some: 'data' }
         * console.log(cache.get('https://example.com/')) // { other: 'thing' }
         * ```
         */
        allowStaleOnFetchAbort?: boolean;
        /**
         * Set to true to ignore the `abort` event emitted by the `AbortSignal`
         * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls are not
         * immediately resolved or rejected when they are aborted, and instead
         * take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFet‰r}r“ºl€¢Æ‰ f˜=u£w‚ª“ª·›¹lsvoSŒ† ‚uŠ®c¥{Y£‹±| „‚‘“˜šx¨w’Y²‡‹_…¢^~}k lz‘‰›„‘Éœ±…‘˜~¼d™€‚•ÃªwrŒx¬\€T]‘cx‚~£z U´†¢||¥si\To„Œy£nÀwnJ]¨U¿ºtxŠ‹¤Ãkƒ‰\¡ˆ†eq[qj–N©]]†sl„ÙSÓNx~¹£—«¥²„MÂ‚«•ƒw¤“fo{” |¬‚u7S]›°—µ¦±ng}ˆFºkuÑ—¡Xi‚Fk±›Œyt”{š³™gA™”ä¢ÊZœdœ±Ä}–ƒ©n–yQ¨e¸é‚tu­Èu£¯Ê¸“ŒÁ¥„«–»Æœy‡c›¤˜ œ±©ˆgp}ˆ{ŠluŠ’Š¥K€j©µ‹Äsy{vks›š˜w“y \Fo§_—¸T{}–£ÅË†>wƒm’“}Œ±k‘Efp¡IX‡°~x…­_p“˜k»¯|‹ ¥rÃ˜b|myUhzš»•‹2qˆ’¨Â„t vÁ˜ˆYod©¶„´y­NK†hK°†–¹|ˆd‘b\ltª¤ºn¸Vp™®€š·¥ªy­h Â±1I©²u®×£“~£¨¼y‘~¹Jz—™…Ÿ‘p¶Á›—ge‚mz‚e‹t©U}‘·«Ÿ¬Rzu•a……§i‡}¥€M…“c·`’ _ ‘§ŸŠn’œpbmt³šuŠgN‡gl€§rj×Vt†—y‚Œ ¹—WœŒ®XÉ®rb€””­•Æ–m…†˜ƒˆ ·Éª€˜€´§™±™X|ƒx£±Œ›q€½Ÿz­U^jdyŒw£¢ƒ™…¡p„nq”Œ~©š•…‡s}•nk“O‘•‘ˆ‚ŸŒ˜—ƒ€oc‰†˜}‘n™‰¡˜…a˜­•w£p¤wˆ—°tiˆ–mŒ‹›¾lywg[„oÄmvjt‚•€’©vu†…t¢bdT‘–§£ƒ”t¨›ssk­•{ˆ‘‚[m¦‚v{r— ‰v{“cš’s€´°‹„q¯x »¤ÂXÀ…³±–¾o—†ª€’–r¨·¡¸‡i‹~ª¯¬·Š™Xsq~Š{f–Š‹Zs^˜›rƒ…eŠ½˜yŒ{‡Y€fS¯‚}†˜’~¢Ã„Éw’Œ~}kr¦v§q{T“r£‡¢z‚†“«³¦‚’†vƒsy¤¦œ[‰W|l‡–t€–{©‘nh~˜†x§nUDmt¢d¢i£ˆ˜¡t cn®œocŒ|k‹„dŒ€‰›€wŠˆÛ“f‚‡iv€…poŒ‰«¡›¢P®—‰ ‘…£Š¤‡ ¤¬‡uRu–o“¤™˜½‘—Twx{up°x‚D’Q’¤yz}|¥‚œ“u‹}—‚Rš•r€‘“»j”¹jŠ³•jh±wo¥‘–™„}‘Œ™„•¸•˜‰~È ƒ‚v‰bƒcm‰š†|aŠq‰†‹‹‹h•’’‹‚„mƒ„wp‰z†„–‚k•j†xŠ‡}—pœ”§qqlš…œdŒlu—šw‹œWê}}–wr|{œŒ‡›Œ…œ—›…˜…ˆ–sŒh‡ˆ†ƒ—€u›ntƒ˜‘’’…–‡™x‰Šq–…j“†‚–Œ’‚‚ˆˆŒŠwƒ†‰†t¡‰œƒ‹‚‹¦”~‚Œ–Š”}†‚|€›‹‡Š‡Œ‹”Œƒ†•‹ˆš‰‰–‹ƒˆŠˆŠ‰}‘ƒ€{}Š“”•~Š•vŠ‡}‡—ˆŒ’…uŒs…‰Š™‘›„†‡‹˜‘„‘†“–ƒŠ’—€…Š†’†™xxˆ„Š‹“‘—£Š˜„‘”~ƒ‘~‡‘~ˆ€y€ ƒƒ…•”•“’˜ˆ‹’ŒŸw„‹‰‘€†‘„‚‹—}„ƒy…Œ…šz~šŸŒ’ƒ‚ „’}‡¥‘„ˆ…~‡‹’‹‹††Œ‰}†€‹…‰‹…{ˆ™„“yˆ†~‚‡‡‹~†}‰“„ˆŒ‰†‰€€Œ}ˆ‰‹’‰‹Œ{Œ„‚‰‰„w„‰“ˆ’‘˜ˆ‡”•†~™•ƒˆ‚…s›‰ˆ”†’‘ˆ–„„•v˜“Œ‡˜ƒƒ“Œ‚Šy‡¬„ŒŠ•‹–Šˆ‘˜–•›ŒŠŠŒ‰“ƒ†Œ~‹”ƒŒ…€‘š†‰~sˆz‹…ˆŠq˜ŠŠuŠ‡…—€Š‹‡ƒ‚†šŠ‘…‰‰…†Œ‡šˆ…{…z”ƒ‡t…Œš’x|‰ˆ•Š‹‰Š~‡ˆ‡ yƒ€}…ƒ†‹—‹ŒŠ‰}‰ˆw}‡Šˆ~š‰’“ˆw„{~ƒ…˜‹šzŠ‚e–—~s£_‰¡¸¾¹fŒ¸x¦o³˜†…dnv¬cn¥ ºs’˜—ˆš‚V˜zyx§f¥}²‘’‰¤x‰z¢’€À®ˆœšerx™]|p[¥£k{» «©sj…l“«œ€s“bn™f€¡œ‘‹¡ˆƒdo±‘w“s’{w–r{›Æ•w¥º„tzyso†}™y‰}j‹|°Ÿ…’˜–Ÿr¦k’“¡ˆ‡tˆZ„‡ƒw’ƒmhŸq˜Œˆi“‡|yŒ‹z‰ny‘Ÿš‘™‚’²˜—|¶bŸ…‘m•h‰•yef¤˜˜ƒy´‚¦˜g¤”w–h€€€—y­”}’£’‰†¶’pwaŒp~m††–€o–‹n¦xœcjnŒ¥†³”zsq‚Yw‰›´†”ƒ¢¦€t†w¸r£®w‡ƒ†o˜n‰¹ssÍŸ§—‰ij_nl€“—ƒœ¨pg£”‡˜yu…«•‹x–n‡ _joe|¤Œš§”Š‚‹}¢¶´‡£ŒŒfœˆƒo‘~š§˜ŒŒœˆ€¯…©Lv¥~}˜‘bz™{bog¨›w•’‚™¥„y‡“ŒizuŠ‡–¨ ™`‰©h”‚Š±”y•p™‚w|_ pš‹„–oui­lnfy›m›r“šjdvAx n¯Ö}‘u˜w£¯ˆg}dr…v‡}Í™wX—k†ÃzzÆŠ²“ztTw|_siŸ£”…§nrœ“~|cczµ£YŠi©bgRmtÂŠo¦ „{””Ê•¿yo…m„€qˆ’‘ˆ_”——wsv† U~x|•‚Ÿuxmœ“‡œ«‚š™‡’‹˜t‡ƒot¯|¤]ƒƒu¦„©‘‘p¡Š‡“w…u‚……z•ˆ­ˆ…{—‹z¢¡¥‘–Š„¢w~‡|‘ t–zurs’q€‹wƒv…Šš›“™•‹ˆ†}”’z›ŠŒ††u—¡Ÿ’Ÿc¥‡˜˜”ˆƒ_¤s‘‹„•Œ¡”†„y©vŠ©Ÿ}˜”Œj¨~z˜{g—„oŠ|}—vd‘„®|ŠŠkwjj~‰•v¢qu®|‡Œ†p†…‘¡‹†v{›•‚zb¢t§x¡j„€„Œf¢£™–t›t|ƒx‡yq€Š‹y‹‚•†š‡~‡©‹—d›„ƒ–…”µ{}spk‹„–ƒŠ‹’¥“{‹’†€š‹ƒx—vx™©šƒ~x–™™›ˆ£Œˆ‘–s—£ƒ˜’ˆ›v¢š|”¯‚“˜Œ˜†€‘„ˆ‰¤‹”|•‚‹€rs¤ƒ‡ˆ‚eklv•—Š’€Š¯‚|€x“ŸŠ~Š£‰€rŒ–‚«ƒš‹wU—¯t¡„‹pˆy‰£¥›–€†t‡zo‚oŒ”ƒˆ“h†‚¬wš†„“_i˜€“‡q±z§yxyƒˆ‰’£{””ˆ²Š„ˆtx†qx ‡Œ‡—™“’ˆ“b†‹x¯–n‚Œ…‰¯€›”¨˜›…”•Ÿƒ†~˜Œ–‹u©~‚‰f|uf˜¡˜£§›|€¨‡’ˆbŒ˜t¤¦¡’Š„§a˜ˆyˆŒŠ‘~“qp—v–•¤‘u‹”™–x±•‹«…•®bww™ƒ‰˜œj}€‡‰v…˜wv˜Œ’­„…ŸhƒaŒ~’‰ ªŸn¨¨¢‹ˆv›…¡}–y“„“„_{s²¢†™~‰‚ˆ Ÿ“my}«€¡€•­‘t¨š¦³`p~ys—¥¢™|‚€¢—s´…yŠš—x…ŸoŸ¦y­™™™i’´Šªˆ‰—ƒŠk­¢‡t‰’~¦Ÿ™‚¤p”‹‘”Œ‘y~zƒ}‘º¤˜“‘Ÿ‡|w€|™iŒ­˜„z‡{š~—y††¤“b€f‹jwp’„¤}w…€\‚x‹•ƒxˆ©g£œq§€‹t¤}|—l†’s†ƒ“–‚Œ}¢ˆy§¥mw•z ‚¼q€€d{˜¡‹}‹si„«ˆ­ˆ„”k™†„“œ‘‘€x›w¦”–‡—¤”œˆ{¦™™‚y’y‘x¨“£”€Œ‚’—m¦—”‰Šˆ˜•‹u‰…–›‰| ‡“§±{‘œ•“ ‘‹p‘wX—‹¹‚o¬‘ƒ~†y‚˜q†‹“¦nyˆsŠŒ‡…¬†~xƒdn¤«ˆq†š–´¬}µfˆ‰{rˆ“Šw˜’mw|x–¡…{f‡¾g£ovzªu¡knnz„s†so…‰Š¥³Š¡’“¡€ }‡rv‡¦‡}Œqtš„”}x‰‹–™””•£‰Šw—´“’Ã¦|œª[tŠˆ•—±©jjW˜“„’Š›²‰Œto…‚§Š©Š^™Ÿ®›˜Ò¤t„ŠG—®Xr—} ’˜m³´Ewh¨§¢‘xmu¥´¤T~‘~u‚•a“°˜Š–•©‚›“h‰~¤‹’~‘˜‡ ™¤š¦­…»}“Ÿƒ¦¶‹m˜–­ƒ†q­‹•œ‰…„‰x•‘‹¡ …{‰™r„ŠŠ³|‰º‘±so‡¨›ze‡u[Œ‡yª~w«®‰qƒ®º˜›x’•{²aVvaŸ“¢ƒ‘š€˜‹¤wm—m´‰Ÿ}k‘–²¼…Š\wz‹ ¨…§™‹…¢•’ÕW‚ƒ›˜ˆ–“pi‹ˆˆ|‚–sl¤Œ—›Œ†{Š‹~šŒ{’Šrˆsµ˜Ífš›­œ—zƒ•…¡Y ™­ƒ•‰Zœ‰‰„kŒŸœr†¾ ¢s¹’r“”y}‡š¨{…Œ‹Ÿ~™Ç…¢pl€¤ˆrb«\e‘€k•”¹g{„»¡†¡œpc¡|t¡h}¡–šˆ–„y„ƒ³±|™|vŠ}fj‰{™n¢šnˆº|x‘ŒŒ¥®svƒ—‘³u”ˆº†u‡}W•yx”“¢p˜Ÿ·©› ‡yªx“c‰š\˜”¥†“‹m~d‚oª§¥‹Â]“y­‹‡Šdr’d–‹ŒˆŠ{‚r‹‰‡„c‡oŸq³˜¢y¦„È}}‘Œyƒ‹‘z|pziˆq›­›tŸ‰V}‡košu®”c»€Ÿj¶©Uƒr­€˜i¢“›”ˆ·…o†µ†>‡vgx{•‹Œnni†|‰‘µ‘ª°¤„NkVŒu©”rÅŒ‚mj”š§…­¹zN\n…bpŒH€yª¿/Tˆ†]¥¤8ˆy¶w£ph_x’‡…n{Y³}…¯rVy?«œats„“›¬Âœ”r«‡¬{­Z |1~¤a¥e­o­‘_[s8³nÈ‚—°› i›®tº™‘‰±zc‚¥f¡»nsZb¾ }¾lš¤`€}¥d‚yr£g¹}[¥½²G†ªdŠŒr{Zt›†]±m™‚u}Ym¦‡r|[‰£x·¸ƒ‡t™pC‰°‘ ¬·¡€ƒ¤pg£z©¢£ujŸnf­¦‹‘k¸Œkˆ[z£­]q…Ä´•t†­´™bœ‚mzXf°Æ‡WWˆ€„Š¤’mmš…Àƒ²ljµxZ”i·qbt¸~ƒl¶} |ÒÜ“Vrr]›¼…¶Ôq‘–©›”°­xs’m—ŒkvX•ˆ|m={FlªYµ´o§m‡¼†Pg›Ç~©¦qŒ”°r€pr}£‰o~U¤˜Š}R‡‹Æ­Ç¥¦•™d¤Ysœ»Ç¶d€–`gÓ˜š’»‡n¢hy”w˜•tyf{™_ju¿Œ°‰› ‡Ÿµ¢›¤ÅyxLcœ®—v‰Mom›É‡¢ ®^…ªh¸‹R…^h|pƒYrTp€_r©„i~°Æ §’R¡³U¸î“¨µ ‰†mŸ…{jŸT€{{|…1h~j@­x^ijo‚¡r†¤šs˜ˆ|iƒ€t~…”j„‰‡‹«‹‹ƒ‘¿…b†¤Œ‘²¡²ƒ{~z¬“•²¡utc}{¡”…‹Ÿ„€´r{’‚¤h—e“c—¥Œ®Š°{‹}hmz¡š”ip¡g‰’y‘Œw¤£n{§ww t•…„°yŒ£ —¡oˆ‚xsqk¥l„{e‡±”txƒ”€¤y¤ƒwŸ{—e‹lšÇ—f’„v¸¢“|}h¡~–ybœ‹ˆ‰ i—¤ƒr¡~…‚p}‹‘””wu‘™‚ “›šw{¿–tª‡rxi¡¦‚n¦‚¦‰¥m¦‚q’—’‰“s©Š£vq~s’‘¥dp¢U‹‡n˜‹”{lˆ„x—®£‚¿l–„‡‰–€£|\€‹šp†ŠÄy—\qŸ™”¹¢™d–mtu|z£I“”ˆ€r„“|nl†ˆz|Œ©ƒrˆ¡±jqs‰s‡›o¬‘ˆ…†”•—”˜u‡p±‚—£ypv°™Ÿ‘z|‹j}‰’ˆ‚–…sp{¥µs›‘y|nˆ†|v¯†Œt„¯„§œ|’r™™pƒo–‡p…˜“‡œ ‹’~“Œ“wªyn}u{v‡Š“’Ÿ€e‚Œ•–š™’~Œšq‚’‡qmr‘…š­ztpŠ£~‘™•°zš†sŒxv`š›ˆ T‚…~tŠv{]O~„q–ˆ£s—p­—z_¤t˜s‘š‡’z…„†z§„_‰›Œ^˜vsŠ“š¥ªWŠÅ†u{‰†pb˜¤µ—’’ˆn€¥‹‘„pn‚–o”’iƒf³‚€Àwy£–©__z•’•Œ«œ‹’ƒp}‘’zƒ‡š¤pœˆ“º‚›¢½|™r¥”Âx`€Š}—oŒ‘<²‰‰bŸw~–¨tu‰¶‰~ƒq––CˆÂÎzœ…Ššd{˜‰t©Œ£µà|›}Š©xÄrw³|“j|mot¥Ì¦¡‘wnxd³’\“{\Í©‡€d™£´cbˆv±œ÷šp†eV¦V–•—¡¶†ˆ‡u‚˜…‚gl”–n¬V«n‹°™²´¯V¬x{µ`hw©›t„o¥§€>z—qy•z{{Œs—}~¹||“¹‚¹¬{£n|¢~vS{qin~‡–™„Ã•m€‚¥`³~Œœ V€e€™Š—„›®N‰ª}‹™myˆ‹[›k”£©£b|o½ ±›wg‹Šˆ”¡£x•˜–Y‹czª‹y{µx‚—Š’›‡°¡jc›®€­vyf‡²«vTlBª~‡Á³”‚™¯Rdœ­p‡¬³ur¥™fŸxÊƒÆ´µ¾«\d¬ÖnwywMµŸ¡¦‚j›[H¼d†rW€ƒŸÊYŒªuk„Š‰`u¶~arO‘ouŒ‡l\£³¦·†s‹µÂ`~–Ÿˆv—N¬lrˆ‡œ”ˆ†”og•º‹²‰‡”‹a‚—€´“|”…~Â šŒ•‘…˜£fƒ•®‹›weŒm‹}£‹•TŠxˆ˜¯š—«]of€¼©tqŒ–œZ‘–“‚Ÿ}r¨p˜˜–¦±cHr –˜›h’Ÿ~Çyv‰†sys‡Tb³µ»Qi~o~_r¬–© Ÿu ¥[Á¨^‘pG£²as°¥¢zÍÛ‰y—Œ“n€‡‘©¡‡—Šˆ¶ª§‰ƒ›h²†ƒ…wb¡r™–˜ukœˆ¢pyŒŒ›£†…}œXƒ}ƒTxk|…c~zb¢ƒ€~¦u—dolZu”É¸¥t’rpm“r£‰“·¬ª¡R“{¥[\Â©qk‡|…o’l}cn‹©¬ »bt~¨K•±‘É¹¤Œut§3W†t‚Ši„ŒŒ’…q†Š‹»mv¡JaLœ×©˜ˆ³}ÈV¸q³ro‹nx‹\§Q©¿††¡ÈŒw{ay¶k–M°‡•wYÏ¥›„Y¾˜’‹mª„uu¬¡lˆ£‡ ”‚v|~‡}q‡Y~y|›YTŠ\yZ_Œ°‰uySpkª¨o™w_‹j`oŒ|†Œ”‚—V€€´«gxˆˆ–s­Á ¦hm¦{LsÆ¥¢Œ¦at†™vj“‡•ÇÜ~ˆƒc¨¢Š±P—­xozc“—\~kzww‘¹Ío•—V}i¥€w¤®Št¦€¬p¤o¥T|k|‚‡¤Tt€p©Ä|§zŒ k‚¥‚„™†B†€Œoš–‡Ÿ®­ Œ¡{©cS›‚¹†¤iw¦‡ÁŸ™‹ˆb€¡t–‡‡f]k¼|ju¦­¡s«’Œ¦‡h”„¼z¢N¡xs”–hvwšPƒ–«•~©r°TZ—‘£¤£B–´na›~œŸ§xdk“”¬£°±kzkp¤Œ’~††‚²‹Šƒ€v§“¢R¤|’ƒx‰…›£¥i—¤ˆ‚“f’®k}­›j¥§„ˆ£±†·‰„yx°¤–—†¦l‡z‘™—nŒxn€—‘–¯…“p¡„š®|‚†‚€¡z†|uvxwxky—uœ¡‘s£qƒ¤­myœjl«ms^nw‚‰{env„|¢i»•n™sv‰‰…d‰—n¸xŒ”¥‰}š™}˜‡ŒyŒŠš¶™v¡¤fkvpz…Ši:ËrˆnV©—Ÿuy‘Ÿ€„p–¦”•—‰‡M‰g€—¤‘Ÿ–z|•“Š„Œ™¨˜¶¼¬{Ê–‡™£ÀŠ¢q¤]|‘’“Ÿ’ou‡Š”‡|…‡„ur’£˜“x£ˆ‘qœ‚xvˆ“†`q˜v–€sr}¡˜œ’x|ˆuo‰Š„‰w~h†ˆnˆ‰•–t~£‚s‹”„¤Ÿ {”–…ÃŠ‘}ƒ~ux~š“˜Š´››w‹‚xu‹‚{€œ{šgœ‡ˆ›¦…š‰•‰…m}–lŸ{©zƒŸx‡£z|•£™‡ —v‚©¢­{„°Š“‰´¥“‘‹€º‹Šn{|ƒ™™y§Œ{…¶|{œ‡œ{§~z‹™ˆ‘‰¯›‘–€±–€¤}y{k~—†l†{‡š¨^‹„~‹‰§“z‡[¤r‰‘y‚€‰˜q|w™v}z³‹z‡‡Š‡ ˜¥¢N—‹eŒ‹q—’q•©£…_pwpƒ§…”vƒ¨®ssŠ–w–™€š‚‹…{—~‹y†Æ™h¯‚œc­Î¡‹eyo^Èxš‘…‡œo„œ—iy–vh|¢tÀ«¤€Tm…ˆ™—–œh£njpƒ¥tp«\i†Ÿ§vaª‹œˆTªˆ…Áˆ{”„“©ƒ”š~šˆ§s˜I­Š¢h“˜„xwŒd‚‡Sjƒˆª‹»†h—”i}‘tÀ£‡‡ƒ«v—sHu”¦”Œ¢£’x”}w^l…kzØr¤duyƒ›£„••¡s’£šˆ³œ·µSh¹¤ª•ÉŒ…²q©“Sw‹“œ€–ŠgS ¢Åƒ‚’¶~]‹DÏ‡€¯•™‘h`¦ƒy™uWœŸvšx o{~Z†o’dµ›i€ˆ“}kŒ€‘“–u{xuu‡’‡›ƒˆ˜‚p¹gt’«{|œ‹‹pƒ—†tZ–nˆ‘†dtn‡Š­`‹n‘–eqŸ€{†„z™‘v‚s©dhuWa}lz‡š€Š¨‡‰´~yl‡Œd…t~d‘Ìluˆˆj«v§³Œ…•Y†£ –}zxƒŒh‰}ƒˆº”‹g«¥{“ˆ hotpTr›ˆ§eŠtÄ‘d…d°¡€’p±zfUˆ¢Š…ˆ€rœ”²hŠƒ²Š|nov©]¨£iƒƒw³‰…†®”ƒ©{{–Îw¢g¡·”W´RZˆºŠ—…„¢~£lœµ†lw¤‚tŸ‡q–_ˆ”›r“‰PŸn”–v‘Ÿjy|‰ˆ¦¤nCo„Oƒ‰l”¢vt¦h‘ƒ‚sˆPw–c†¦~_ŸL¥œ¯¨„‚rvsW°y¤nu•n“®W¦Px“T§}[¯°Y£†—ƒ‡•ylq¨ ¡›ŒQ‡r³‰‚pp™—x†z½œ³|¤|u{X¥†‚˜®Œg«½‡ªŸ¥¶“s‹Ál…®xŠ€±¦afe·4V€€V·›{tƒ‡zv…–ª•›|À¥•†’Q¯ƒn}hZe½§ˆWc[ÂŸ™ƒ––zkÌ°Š¦2exP¡ƒ}Œ~sŒk„…„±ƒµZm‡¢•Œ„~„k¯¼“šuyŠevŠˆO­{™ˆ”´’³‘€‘‚~†j§|f„¨|§†Ÿ}p›‘t“{µ¥³™…W•‡„Œ¬–¢ [£Œ~†¾²aƒc®m˜Œ”‡¤‹Ç“˜\‚”¥¦™u|­idªŒ…hŠ”’u”˜™{›‡‹’ Z‰ul…‰v‹‘¢‰Š¢¶·¥V¶™š| rZ€w‡†š¶gr‹¨ ¬¨•zq‰€œ•Œw¨§‰tu—¡n… ˆu…¨œy¬‘¢ƒsª©|‘t¨‘–y…W‚†v}”›}d¡{’w¥»¢°‰t’‘ƒl†}€šlwƒ’†‡††vz¦ƒh|“¢­v‰_§Ÿœ¨‰µd™y‹’ˆ¸doµ‰› —‘Œƒ‹Šy˜‹˜ƒ›››‰Ÿ¥•’‹_‘•mw°Š¥’ƒ…ˆŸœ£b•Â|‹¡–›§»œd†“…”–‹ha„u~a£\™¬•‹{v’•s©gj›Xˆ¤“´‘o¨†Á†{ƒ®‚œu¯}qou•¦š—Ÿ’×¤‡e~{l~zzv|€wš¥{„‰†­§š„±™Š~¡lL^¹ ™{Ô“vÃj£›{˜T{Sz§„Œ‹¬k—q•’•UÈ´¨©“ˆ~ƒ†h€„ƒ“i ­n¨IŞŸ†—}§‚˜y¯td†™­Ro«–ª~”´{§~uÆ}m…|™Œ}¸‡x›yfq‡§gpµ€mÕ„£•§vrlj‰‹¾¦‰˜H“q©Ìxµ–„p‹z¬«œ†c…¶¥™“yx¿y˜®ŠŒ}ƒŠ†ÀŒx«§€]‘w‰p‹gx}a–„¤‡|‡}‰swgµ§ˆ˜€m„ƒš˜°Çtª¢‹¸”£cŒ‹¹‚¬‚“F‘p»`•R­q¤¬›eº’™¢}m½|Œ«vxp•ªœ¡x~š•¨Åf„‹Ç£wh“Š‹ Ô~¥–¡‡x¦™…•‚¬’—€€}€˜u‚z|†Œ„‡¢…Št™